## MEMmalloc技术文档

赛题选择：[proj28-3RMM](https://github.com/oscomp/proj28-3RMM)

队伍名称：HDU_702_OS_小分队

队员姓名：夏佳恒、周志奇、赵育淼

指导教师：贾刚勇

学校名称：杭州电子科技大学

#### 一、赛题介绍

##### 1.1 项目描述

在工业控制、航天航空等严苛的应用环境中，计算机硬件通常会受到高低温、潮湿、电磁辐射、宇宙射线等恶劣因素的影响。为了实现高可靠的计算机系统，传统上多采用硬件的升级改造，或者定制操作系统/内核，其成本异常昂贵。

内存在计算机系统中的重要性仅次于CPU，在恶劣环境下会出现单粒子翻转等问题，进而导致程序或系统崩溃。如果能通过软件的解决方案，实现一个针对严苛场景下的内存管理器，有助于节省硬件成本。

3RMM项目的目标是，实现一个可靠的、健壮的、实时的内存管理器，在Linux系统下以一个库的形式对外发布，运行在用户态。建议使用C语言开发，以便将来更易于移植到Linux内核或别的操作系统中。

Reliable 可靠：实现基本的内存管理功能，包括内存池等，在重负载、高并发、长期运行的情况，系统都能正常使用。

Robust 健壮：在内存出现单粒子翻转等异常情况下，依然能够正常运行。

Real-time 实时：使用高效的内存分配算法以及其他技术手段，加快内存分配和读写的速度。

##### 1.2 预期目标

###### 1.2.1 第一题：简单的内存分配器

* 实现一个内存分配器（allocator），并具备基本的功能;
* 支持的接口至少包括malloc、calloc、realloc、free;
* 具体实现可参考glibc/Ptmalloc2、[*mimalloc*](https://github.com/microsoft/mimalloc) 、[*tcmalloc*](https://github.com/gperftools/gperftools)、[*jemalloc*](https://github.com/jemalloc/jemalloc)。

###### 1.2.2 第二题：支持多线程的高效内存分配器

* 在第一题的基础上，支持多线程和并发 （利用锁机制保护相关操作的临界区）;
* 通过benchmark测试，benchmark的参考实现为[*mimalloc-bench*](https://github.com/daanx/mimalloc-bench);
* 根据benchmark测试的性能数据，以及测试中占用的物理内存，综合评估方案，目标平台x86_64。

###### 1.2.3 第三题：支持内存池的内存分配器

* 存池是一个块预分配的内存区域，基于内存池的内存分配和释放都在内存池中完成;
* 支持基于处理器核心亲和度的内存池管理（以提高访存性能）;
* 支持的接口至少包括pool_create、pool_clear、pool_destroy、palloc、pcalloc;
* 参考实现为[*apr_pool*](https://github.com/apache/apr)，以及Linux的NUMA机制。

###### 1.2.4 第四题：高可靠的内存管理器

* 在第一题的基础上，实现一个高可靠的内存管理器;
* 可以采用校验、备份、三模冗余、纠删码等各种方式，实现抗单粒子翻转的功能;
* 已分配内存的1个bit值出现错误的情况，依然能够读取正确的值;
* 对有异常的内存，能够自动修复;
* 上述处理层的加入，内存无法直接读取，需要内存的读写接口，实现内存在读写中数据的自动冗余备份、校验和纠错写;
* 本题测试方法：程序运行过程中，外部检测框架修改特定内存来模拟异常，程序内存不会出现读写错误。

###### 1.2.5 第五题： 3R的内存管理器

* 在第四题的基础上，进一步提高性能和实时性，兼顾3R (Reliable 可靠，Robust 健壮，Real-time 实时）;
* 使用benchmark进行测试，根据性能数据以及测试中占用的物理内存综合评估方案，目标平台为x86_64。

##### 二. 比赛题目分析和相关资料调研

##### 2.1 赛题分析

赛题的基础是要设计一个高效的内存分配器，之后再在这个分配器上加一些额外的功能，比如抗单粒子翻转功能等。所以我们认为赛题的重点在于如何设计一个高效的内存分配器。

##### 2.2 相关资料调研

对于这次比赛，我们做了如下调研：

* 阅读mimalloc源码，找mimalloc相关博客，了解mimalloc设计思路
* 阅读庄明强的《ptmalloc2源代码分析》，找ptmalloc2的相关博客，了解ptmalloc2的设计思路
* 找tcmalloc的相关博客，了解tcmalloc的设计思路
* 阅读上届优秀的的源代码
* 看相关论文：《NUMA架构内多个节点间访存延时平衡的内存分配策略》、《TLSF: a New Dynamic Memory Allocator for Real-Time Systems》

##### 三. 系统框架设计

##### 3.1 结构设计

###### 3.1.1 整体架构

下图是MEMmalloc的整体架构：

![memmalloc整体架构](https://s2.loli.net/2022/06/04/wVP1u2EXHykKvxq.png)

架构说明：

1. MEMmalloc将内存分配释放方式分为3种：小内存分配释放、大内存分配释放和超大内存分配释放。其中0-4KB的内存属于小内存，小内存的分配释放的基本单位是block；4KB-1MB的内存属于大内存，大内存的分配释放的基本单位是span；大于1MB的内存属于超大内存，超大内存的分配释放是由mmap/unmmap来进行分配释放的。
2. 由于小内存的分配释放较大内存的分配释放更为频繁，所以我们为每个线程都配备一个线程缓存池，线程缓存池专门用来存放block（小内存块），线程缓存池的设计可以减少内存对堆的争用，从而可以达到快速分配释放block的作用。
3. 对于堆的设计，我们设立了一个小内存堆链表和一个全局堆。全局堆初始时向操作系统申请1GB内存。当线程请求block时，首先会检查线程缓存里是否存在相应的free block（空闲内存块），如果有直接分配，如果没有则向小内存堆申请，小内存堆如果有满足要求的free block的话，则分配一定数量的free block给线程缓存，如果不满足请求则向全局堆请求span，再将请求得到的span切分成相应的free block并分配一定数量的block给线程缓存。当线程请求大内存块的时候，则直接向全局堆请求span。小内存堆链表存储着一定数量的小内存堆（默认3个），小内存堆专门用来存放free block（空闲小内存块）。初始时将一定数量的小内存堆链接到小内存链表上，但是只有第一个小内存堆被分配了初始内存（32MB）。当一个线程尝试向第一个小内存堆请求分配小内存块时，会试着对第一个小内存堆加锁，如果加锁成功，小内存堆就会分配一定数量的小内存块到线程缓存中，然后线程再从线程缓存中获取小内存块，如果加锁失败，那么就对第二个小内存堆加锁并向全局堆申请初始内存（32MB），之后重复上述流程，如果请求的小内存堆都被上锁了，那么线程就会默认等待第一个小内存堆。设计小内存链表的理由是减少多个线程对小内存堆的争用。
4. 小内存堆和全局堆会优先分配未被使用过的空间，一定程度上有利于内存介质的磨损均衡。当全局堆内存不够时，会通过mmap再向操作系统申请一大块内存。

###### 3.1.2 span设计

span是大内存分配释放的基本单元。全局堆一共有256种不同大小的span，第一种span由一个页构成（4KB），第二种span由2个页此类推，此外，span还支持切分操作，大span可切分成小span。全局堆维护着一个数组链表，每个链表下挂着特定大小的span，链表数组如下图所示：

![全局堆数组链表](https://s2.loli.net/2022/06/04/1F5yqOJjiXUkvmD.png)

由于内存地址是按基础span（一个基础span的大小等于4KB）进行分配的，即每次从主堆上切分的内存大小是基础span的整数倍，同时，主堆对基础span进行了标序，即第一块基础span是0号，第二块基础span是1号，以此类推。所以可以通过如下代码找到目前的内存地址所属的基础span序号：

```c
//ptr表示目前的内存地址，pool_start表示主堆的开始地址，SPAN_SIZE表示页+span结构体的大小 
int index = (ptr - pool_start ) / SPAN_SIZE;	
```

此外，全局堆维护着一个映射数组，数组保存着每个基础span序号对应着的span结构体地址，所以找到基础span的序号之后可以通过这个数组找到span结构体地址，接着获取span的一些相关信息。

当线程向全局堆请求大内存时，会先检查全局堆的未分配过的内存是否满足线程请求的内存要求，如果满足，则直接从未分配过的内存中切分成span分配给线程；如果不满足，则搜索全局堆的数组链表，如果相对应的链表中有span，则直接将span分配给线程；如果相对应的链表没有span，则检查下一个链表，如果下一个链表存在span，则取出span，并将它切分成两个span，将满足线程请求要求的span分配给线程，将另一个span重现挂到对应的链表下；如果下一链表没有span，则继续检查下一个链表，重复上述操作，直至找到span或遍历完整个链表；如果遍历完整个链表之后还是没有找到想对应的span，则扩展全局堆，向操作系统再申请1GB内存，之后再从未分配的内存中切分出span分配给线程。

###### 3.1.3 block设计

block是线程缓存和小内存堆之间传输的基本单元，它由全局堆中的span切分得到。当线程请求小内存块时，会先检查线程缓存是否有相应空闲内存块，线程缓存维护着一个数组链表，每个特定大小的block都对应一个链表，链表结构如下图所示：

![线程缓存数组链表](https://s2.loli.net/2022/06/04/p2QKVegJfjtD3nP.png)

如果线程缓存中的相对应的链表有空闲块的话则直接分配，如果没有的话向小内存堆申请，小内存堆也维护着一个数组链表，每个链表下挂着一个个span，但是特定链表下的span只能用来分配特定大小的内存块，小内存堆的数组链表如下图所示：

![小内存堆数组链表](https://s2.loli.net/2022/06/04/gQ2RmjlzrtdOuZa.png)

如果小内存堆相对应的链表下有对应的span，则从span中的block链表取出一定数量的block分配给线程缓存，如果该span的block分配完了，则将span从链表中摘除；如果没有span，则由小内存堆向主堆申请一个只包含一个span（4KB），将该span切分成一个个block，之后再将span挂到相应的链表下，之后从该span中取出一定数量的block分配给线程缓存，最后线程再从线程缓存中取出一个block用来分配内存。

##### 3.2 内存分配

内存分配的流程图如下所示：

![内存分配流程图](https://s2.loli.net/2022/06/04/WDsyHPYZG38FAVx.png)

##### 3.3 内存释放

内存释放的流程图如下所示：

![内存释放流程图](https://s2.loli.net/2022/06/04/r5mevdLH8jAPca2.png)

##### 3.4 抗单粒子翻转

我们参考了上届优秀作品TRmalloc，实现了三模冗余法，同时又增加了奇校验法。

###### 3.4.1 三模冗余介绍

三模冗余系统简称 TMR(Triple Modular Redundancy) ，是最常用的一种容错设计技术．三个模块同时执行相同的操作，以多数相同的输出作为表决系统的正确输出，通常称为三取二．三个模块中只要不同时出现两个相同的错误，就能掩蔽掉故障模块的错误，保证系统正确的输出．由于三个模块是互相独立的，两个模块同时出现错误是极小概率事件，故可以大大提高系统的可信性。

###### 3.4.2 三模冗余应用

在申请大小为size的内存时，memmalloc会分配3*size大小的内存块，将分配到的内存块均分划分为3部分，第一部分为content，第二部分为copy1，第三部分为copy3，在写入时直接将所写的内容重复3次分别写入不同的内存部分中。读取内存时，首先是要比较三块内容是否一致，如果三块内容都一样，就说明没有发生单比特翻转，直接返回 `content` 中对应的内容；如果有一块内容不同，就认定另外两块内容相同的块是正确的块，内容不同的块发生了单比特翻转，用正确的块内容覆盖内容不同的块，然后再返回 `content` 中对应的内容；由于只有单比特发生翻转，从而在一次读的过程中必然有两块内容相同，采用三模冗余的方法能快速有效地检测出单比特翻转错误，并将其改正。

###### 3.4.3 奇校验

奇校验法是最常见的一种数据校验方法，在存储数据后附加一位奇校验位，用来表示数据中“1”的个数是奇数还是偶数，为奇数时，校验位置“0”，否则置“1”。当发生单粒子翻转时，数据中的“1”的个数就会变成偶数，所以以此通过判断数据中“1”的个数是否为偶数来判断是否发生单粒子翻转。

###### 3.4.4 奇校验应用

在申请大小为size的内存时，memmalloc会分配到2*（size+1）大小的内存块（1表示奇检验附加位），将分配到的内存块均分2部分，第一部分为contnet,第二部分为copy，在写入时计算数据中”1“的个数是奇数还是偶数，为奇数时，校验位置“0”，否则置“1”。读取内存时，首先计算两部分数据的“1”个数，若都为奇数，则没有发生单粒子翻转，直接返回content的内容；若其中一部分“1”的个数为偶数，则发生单粒子翻转，用另一部分的数据覆盖该部分，再返回content的内容。

###### 3.4.5 总结

​	在后续的性能测试中可以看到，采用三模冗余的memalloc读写速度要远远快于采用奇校验的memmalloc，但是奇校验法相比三模冗余也有自己的优点，就是较为节省内存，因为它只需要申请2倍的size大小的内存，而三模冗余需要申请3倍大小的内存。

##### 四、 系统测试情况

##### 4.1 功能正确性测试

请参考/doc/TEST.md

##### 4.2 性能测试

进入benchmark目录下然后执行sh run__tests.sh即可完成测试，生成的图片放在benchmark/images/下。

run_exp_test.sh会依次执行

- exp1:对memmalloc、ptmalloc、trmalloc进行测试，测试内容是单线程下，单次内存分配大小从64字节开始，之后每轮增加64字节，直至1024字节，每轮分配重复10万次，得到的测试结果如下，在这种情况下，三个内存分配器的测试结果差不多。

  ![exp1](https://s2.loli.net/2022/08/14/fiBJo36ZyW2RGIX.png)

* exp2：对memmalloc、ptmalloc、trmalloc进行测试，测试内容是在20个线程下，单次内存分配大小从64字节开始，之后每轮增加64字节，直至1024字节，每轮分配重复10万次，得到的测试结果如下，在这种情况下，三个内存分配器的测试结果差不多。

  ![exp2](https://s2.loli.net/2022/08/14/lSU8BJaQdCPRwFc.png)

* exp3:对memmalloc、ptmalloc、trmalloc进行测试，测试内容是在单线程单次分配256个字节的情况下，分配次数从1万到15万（间隔1万），得到测试结果如下，在这种情况下，三个内存分配器的测试结果差不多。

  ![exp3](https://s2.loli.net/2022/08/14/C2prn8tdEAFqIge.png)

* exp4:对memmalloc、ptmalloc、trmalloc进行测试，测试内容是在20个线程下，单次分配256个字节，分配次数从1万增至15万（间隔1万），得到测试结果如下，在这种情况下，memmalloc和ptmalloc测试结果差不多，trmalloc测试结果略差于其他两个分配器。

  ![exp4](https://s2.loli.net/2022/08/14/28HyTsnMO1igEFI.png)

* exp5:对memmalloc、ptmalloc、trmalloc进行测试，测试内容是单线程单次分配随机大小字节（0到32768），分配次数从1万增至15万（间隔1万），得到测试结果如下，在这种情况下，trmalloc测试结果最好，其次是memmalloc，ptmalloc最差。	

  ![exp5](https://s2.loli.net/2022/08/14/cAtFWG74KhUwv1I.png)

* exp6:对memmalloc、ptmalloc、trmalloc进行测试，测试内容是20个线程单次分配随机大小字节（0到32768），分配次数从1万增至15万（间隔1万），得到测试结果如下，在这种情况下，trmalloc测试结果最好，其次是memmalloc，ptmalloc最差。	

  ![exp6](https://s2.loli.net/2022/08/14/X9O7BTDGvEF85nz.png)

* exp7:抗单粒子翻转测试，测试对象是ptmalloc（无抗单粒子翻转功能）、nsat（memmalloc无抗单粒子翻转功能）、seu（memmalloc采用奇校验码抗单粒子翻转）、tmr(memmalloc采用三模冗余抗单粒子翻转），测试内容是在单线程一次分配256个字节的情况下，分配次数从1万到15万（间隔1万），得到测试结果如下，在这种情况下，没有抗单粒子翻转功能的ptmalloc和memmalloc测试结果差不多，采用奇校验码的memmalloc测试结果好于采用三模冗余的memmalloc。

  ![exp7](https://s2.loli.net/2022/08/14/f4YsCvrAEocFq7D.png)

* exp8:抗单粒子翻转测试，测试对象是ptmalloc（无抗单粒子翻转功能）、nsat（memmalloc无抗单粒子翻转功能）、seu（memmalloc采用校验码抗单粒子翻转）、tmr(memmalloc采用三模冗余抗单粒子翻转），测试内容是20个线程单词分配256字节，分配次数从1万到15万（间隔1万），得到测试结果如下，在这种情况下，没有抗单粒子翻转功能的ptmalloc和memmalloc测试结果差不多，采用奇校验码的memmalloc测试结果好于采用三模冗余的memmalloc。

  ![exp8](https://s2.loli.net/2022/08/14/2z6wHgkNVRfIy54.png)

* exp9:Read/Write测试，测试对象是ptmalloc（无抗单粒子翻转功能）、nsat（memmalloc无抗单粒子翻转功能）、seu（memmalloc采用奇校验码抗单粒子翻转）、tmr(memmalloc采用三模冗余抗单粒子翻转），分别调用这4个测试对象的读写接口，测试内容是单线程下每次读写一个int型的数据，读写次数从1万到15万（间隔1万），得到测试结果如下，在这种情况下，没有抗单粒子翻转功能的ptmalloc和memmalloc的读写测试结果差不多，采用三模冗余的memmalloc的读写测试结果要远远好于采用校验码的memmalloc的读写结果。

  ![exp9](https://s2.loli.net/2022/08/14/2Jt6l9VxhWXi3RE.png)

* exp10:Read/Write测试，测试对象是ptmalloc（无抗单粒子翻转功能）、nsat（memmalloc无抗单粒子翻转功能）、seu（memmalloc采用校验码抗单粒子翻转）、tmr(memmalloc采用三模冗余抗单粒子翻转），分别调用这4个测试对象的读写接口，测试内容是20个线程下每次读写一个int型的数据，读写次数从1万到15万（间隔1万），得到测试结果如下，在这种情况下，没有抗单粒子翻转功能的ptmalloc和memmalloc的读写测试结果差不多，采用三模冗余的memmalloc的读写测试结果要远远好于采用奇校验码的memmalloc的读写结果。

  ![exp10](https://s2.loli.net/2022/08/14/msIcHDQAokN1tTG.png)

##### 4.3 内存使用率测试

执行. exp_11.sh和. exp_12.sh即可完成测试

* exp11:内存测试，对memmalloc、ptmalloc、trmalloc进行测试，测试内容是在单线程单次分配256个字节的情况下，分配次数从1万到15万（间隔1万），得到测试结果如下，在这种情况下，三个内存分配器的测试结果差不多。

  ![exp11](https://s2.loli.net/2022/08/14/WnJM7u1dgKcYNt6.png)

* 内存测试，对memmalloc、ptmalloc、trmalloc进行测试，测试内容是20个线程单次分配256个字节的情况下，分配次数从1万到15万（间隔1万），得到测试结果如下，在这种情况下，三个内存分配器的测试结果差不多。

  ![exp12](https://s2.loli.net/2022/08/14/MWmDL4O9UIpfXH6.png)


##### 五、 总结与展望

* memmalloc的性能总体上要高于ptmalloc。
* 在分配大内存时，无论是单线程还是多线程，memmalloc的平均分配时间都高于trmalloc 的平均分配时间，这可能是因为线程缓存没有缓存大内存块，导致频繁访问大内存堆，而访问大内存堆需要加锁操作，所以频繁的锁操作增加了memmalloc的分配时间，这也是我们下一幕优化的方向。
* 采用奇校验码来抗单粒子翻转的memmalloc，它的读写时间要远高于采用三模冗余。原因在于采用奇校验码需要计算每一个bit的值，这大大增加了读写的时间。下一步我们会考虑优化奇校验法。
* 在内存池实现方面，可以将处理器的核心亲密度考虑进来，进一步提升性能。





